"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[7582],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return p}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=l(n),p=a,d=u["".concat(c,".").concat(p)]||u[p]||h[p]||i;return n?r.createElement(d,o(o({ref:t},m),{},{components:n})):r.createElement(d,o({ref:t},m))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8233:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return h}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:13},c="Block Size",l={unversionedId:"minimawhitepaper/blocksize",id:"minimawhitepaper/blocksize",title:"Block Size",description:"Blocks in Minima are small. As small as a transaction. All transactions are potential blocks. Blocks are just lucky transactions. Blocks only contain references to transactions (Compact blocks in Bitcoin), that have already been sent across the network, rather than the entire transaction. Minima also uses an adaptive block size. The maximum size is set by the chain as twice the average block size of the last n blocks. This allows the users themselves to determine the block size. By filling their blocks higher than the average they will make the maximum size greater, by filling them lower, the maximum will be made lower. Users can drag the maximum block size up or down depending on whether they need it, or whether enough traffic is going Lightning[3] and beyond.",source:"@site/docs/minimawhitepaper/blocksize.md",sourceDirName:"minimawhitepaper",slug:"/minimawhitepaper/blocksize",permalink:"/minidocs/docs/minimawhitepaper/blocksize",editUrl:"https://github.com/minima-global/minidocs/docs/minimawhitepaper/blocksize.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"Quantum Secure",permalink:"/minidocs/docs/minimawhitepaper/quantumsecure"},next:{title:"Block Speed",permalink:"/minidocs/docs/minimawhitepaper/blockspeed"}},m={},h=[],u={toc:h};function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"block-size"},"Block Size"),(0,i.kt)("p",null,"Blocks in Minima are small. As small as a transaction. All transactions are potential blocks. Blocks are just lucky transactions. Blocks only contain references to transactions (Compact blocks in Bitcoin), that have already been sent across the network, rather than the entire transaction. Minima also uses an adaptive block size. The maximum size is set by the chain as twice the average block size of the last n blocks. This allows the users themselves to determine the block size. By filling their blocks higher than the average they will make the maximum size greater, by filling them lower, the maximum will be made lower. Users can drag the maximum block size up or down depending on whether they need it, or whether enough traffic is going Lightning",(0,i.kt)("a",{parentName:"p",href:"/docs/minimawhitepaper/specialthanksto"},"[3]")," and beyond."),(0,i.kt)("p",null,"On a miner-centric chain, blocks must be full. If blocks are not full, there is no fee market for block space, and no requirement to pay any fees at all. If there are no fees there is no security, as the fees pay the miners and the miners secure the chain. Empty blocks are no good, half-full blocks are no good, only full blocks work. Block size must be restricted in some way to ensure this is the case."),(0,i.kt)("p",null,"On a user-centric chain, blocks can be empty, half full, or full, with no effect on the security of the chain. The security is determined by the total PoW generated by all the users. There are no 'fees' required to pay miners to secure the network. There is no requirement to restrict block size, as long as the overall network can handle the on-chain transaction per second rate. The 'Burn' acts as congestion control, to limit traffic at times of heavy load. Each user can determine the load they face independently on their local device and use that knowledge to build a block with a manageable size. "),(0,i.kt)("p",null,"Minima uses a Cascading Chain that aggressively prunes almost all data, whilst keeping a record of total cumulative PoW and the complete MMR Database, so blocks are not an ongoing storage overhead but only a short-term bandwidth and processing concern."))}p.isMDXComponent=!0}}]);