"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[1548],{3905:function(t,e,n){n.d(e,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var l=a.createContext({}),c=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=c(t.components);return a.createElement(l.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},h=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,l=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),h=c(n),m=r,d=h["".concat(l,".").concat(m)]||h[m]||u[m]||o;return n?a.createElement(d,i(i({ref:e},p),{},{components:n})):a.createElement(d,i({ref:e},p))}));function m(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s.mdxType="string"==typeof t?t:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3630:function(t,e,n){n.r(e),n.d(e,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:8},l="Smart Contracts",c={unversionedId:"learn/smartcontracts",id:"learn/smartcontracts",title:"Smart Contracts",description:"Minima has its own,Turing Complete, scripting language for creating Smart Contracts.",source:"@site/docs/learn/smartcontracts.md",sourceDirName:"learn",slug:"/learn/smartcontracts",permalink:"/docs/learn/smartcontracts",editUrl:"https://github.com/minima-global/minidocs/docs/learn/smartcontracts.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Coloured Coins",permalink:"/docs/learn/tokenscolouredcoins"},next:{title:"Incentive Program",permalink:"/docs/minimaincentiveprogram"}},p={},u=[{value:"Token Scripts",id:"token-scripts",level:2},{value:"Global Variables (for a coin)",id:"global-variables-for-a-coin",level:2},{value:"Glossary",id:"glossary",level:3}],h={toc:u};function m(t){var e=t.components,n=(0,r.Z)(t,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"smart-contracts"},"Smart Contracts"),(0,o.kt)("p",null,"Minima has its own,Turing Complete, scripting language for creating Smart Contracts. "),(0,o.kt)("p",null,"Minima, like Bitcoin, uses the UTxO model so writing smart contracts on Minima is quite different to writing them on an Account based model like Ethereum. "),(0,o.kt)("p",null,"A Minima script (contract) returns TRUE or FALSE. The default is return FALSE, so all scripts must explicitly RETURN TRUE for the transaction to be valid."),(0,o.kt)("p",null,"A script can run for 512 instructions. An instruction is 1 operation or function."),(0,o.kt)("p",null,"The process to create a basic Smart Contract is as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Write a script that will return TRUE when the funds should be spendable"),(0,o.kt)("li",{parentName:"ol"},"Create the script, determining the ",(0,o.kt)("strong",{parentName:"li"},"address")," of the script. The address is the hash of the script. "),(0,o.kt)("li",{parentName:"ol"},"Send funds to the script address and set the state variables, this will lock the funds in a coin."),(0,o.kt)("li",{parentName:"ol"},"Add the coin as an input to a transaction. A transaction in Minima is a set of input coins, a set of output coins and a state variable list from 0-255. Each \u2018coin\u2019 has an ",(0,o.kt)("em",{parentName:"li"},"amount, address (script hash), tokenid and coinid"),". "),(0,o.kt)("li",{parentName:"ol"},"The transaction will only be valid when the script in the input coin returns TRUE, at which point the amount in the coin can be spent - in full.")),(0,o.kt)("p",null,"A \u2018contract\u2019 is the script that locks the funds in a coin and is interchangeable with the word script."),(0,o.kt)("p",null,"A transaction can be signed by 1 or more public keys - and Signatures can even be added as state variables if you want oracle style contracts. Minima script is case sensitive."),(0,o.kt)("p",null,"The addition of the state variables in the MMR Proof DB, allow for complex scripts with knowledge of their past to be created. A simple state mechanic for transactional history rather than a global state for ALL transactions."),(0,o.kt)("p",null,"Each user tracks the coins to an address they possess and all coins that have a public key or address they possess in the STATE or PREVSTATE."),(0,o.kt)("p",null,"Minima transactions are scriptable Logic Gates, with analogue inputs and outputs, a simple yet powerful control language, and a previous history state mechanic."),(0,o.kt)("p",null,"Contracts are inherently compatible with Layer 2. "),(0,o.kt)("p",null,"The scripting language supports SHA2-256 to allow cross-chain hash lock contracts with legacy chains."),(0,o.kt)("p",null,"Types of Contracts possible:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Basic Signed "),(0,o.kt)("li",{parentName:"ul"},"Time Lock "),(0,o.kt)("li",{parentName:"ul"},"Multi-sig "),(0,o.kt)("li",{parentName:"ul"},"Complex multi-sig "),(0,o.kt)("li",{parentName:"ul"},"M of N multi-sig "),(0,o.kt)("li",{parentName:"ul"},"Hashed Time Lock (including cross-chain)"),(0,o.kt)("li",{parentName:"ul"},"Exchange"),(0,o.kt)("li",{parentName:"ul"},"FlashCash"),(0,o.kt)("li",{parentName:"ul"},"MAST ")),(0,o.kt)("p",null,"Example multi-sig contract: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'scripts action:newscript track:true script:"RETURN SIGNEDBY(0x1539C2B974C1589C6AB3C734AA41D8E7D999759EFE057B047B200E836BA526 8A) AND SIGNEDBY(0xAD25E1E40605A68AFE357ECF83E51FE27EC10013851AE95889A00C695D5B94 02)" \n')),(0,o.kt)("h2",{id:"token-scripts"},"Token Scripts"),(0,o.kt)("p",null,"Each token has a separate script that must also return TRUE when attempting to spend a UTxO. For instance this could be 'make sure 1% is sent to this address, for a charity coin, "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"RETURN VERIFYOUT(@INPUT CHARITY_ADDRESS @AMOUNT*0.01 @TOKENID) \n")),(0,o.kt)("p",null,"or a counter mechanism that checks a counter has been incremented:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"RETURN STATE(99) EQ INC(PREVSTATE(99))\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Both the address script and the Token script must return TRUE.")),(0,o.kt)("p",null,"A token by default has RETURN TRUE as it's script. This token structure is added to any transaction wishing to use that token so every user can know how many, what scripts, name etc of the Token is correct and valid."),(0,o.kt)("h2",{id:"global-variables-for-a-coin"},"Global Variables (for a coin)"),(0,o.kt)("p",null,"@BLOCK       : Block number this transaction is in\n@INBLOCK     : Block number when this output was created\n@BLOCKDIFF   : Difference between @BLOCK and INBLOCK\n@INPUT       : Input number in the transaction\n@COINID      : CoinID of this input\n@AMOUNT      : Amount of this input\n@ADDRESS     : Address of this input\n@TOKENID     : TokenID of this input\n@SCRIPT      : Script for this input\n@TOTIN       : Total number of inputs for this transaction\n@TOTOUT      : Total number of outputs for this transaction"),(0,o.kt)("h3",{id:"glossary"},"Glossary"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Mempool")," - a collection of unconfirmed transactions waiting to be added to blocks.\n",(0,o.kt)("strong",{parentName:"p"},"Change -"),"\n",(0,o.kt)("strong",{parentName:"p"},"TxPoW tree"),"\n",(0,o.kt)("strong",{parentName:"p"},"Pulse"),"\n",(0,o.kt)("strong",{parentName:"p"},"transaction difficulty"),"\n",(0,o.kt)("strong",{parentName:"p"},"Block difficulty"),"\n",(0,o.kt)("strong",{parentName:"p"},"base weight"),"\n",(0,o.kt)("strong",{parentName:"p"},"Hash sum tree -"),"\n",(0,o.kt)("strong",{parentName:"p"},"Binary tree: ")," A tree structure where each node has at most two children - a left and right child - and each node except the root has one parent"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Definitions:")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"TxPoW unit:")," A unit of data consisting of a header and body containing one main transaction and a list of mempool transactions. A TxPoW unit may or may not become a block."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Block:")," a TxPoW unit which meets the required difficulty level to become a block. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Target Difficulty:")," A system set parameter influencing the number of hashes required for the network to mine a block every 50 seconds (or as close to). The higher the difficulty, the more PoW (energy) required to mine a block."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Levels:")," The Cascading Chain consists of 32 levels, where each level consists of blocks which, by chance, exceeded the difficulty met by the blocks in the previous level by a factor of 2.\ne.g. A block in level 3 of the Cascading Chain achieved twice the difficulty of a block in level 2."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The Cascade:")," The chronological, unbroken chain of blocks consisting of a maximum of 128 blocks at each level. The block at the root of the Cascade will be the block which satisfies both 1) the earliest timestamp and 2) the highest (most difficult) level.\nThe Cascade does not include the branches."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Super Block:")," Any block which achieves the difficulty required to take a position on the Cascade."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Current level:")," The level representing how deep in the Cascading Chain a particular Super Block is currently positioned."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Super Level:")," Also the Maximum Level. The level representing the furthest depth a Super Block could sit on the Cascade. (Determined at random by the amount of PoW used to mine the block.)"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Base Weight:")," The actual number of hashes it took for a particular block to meet (or exceed) the required block difficulty of 1 block every 50 seconds."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Current Weight:")," The base weight multiplied by a factor dependant on the current level the block is positioned in, such that Current Weight = Base weight * 2Current level no.."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Branch:")," The main branch starts at the tip of the Cascade and consists of the most recent 1024 Level 0 blocks which have not yet been committed to the cascade. If, by chance, two blocks with the same block number are found, there may be multiple branches off the main branch."))}m.isMDXComponent=!0}}]);