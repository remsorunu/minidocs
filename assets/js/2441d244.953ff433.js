"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[4953],{3905:function(t,e,a){a.d(e,{Zo:function(){return d},kt:function(){return u}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function i(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?i(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function l(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},i=Object.keys(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var s=n.createContext({}),p=function(t){var e=n.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},d=function(t){var e=p(t.components);return n.createElement(s.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},h=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,d=l(t,["components","mdxType","originalType","parentName"]),h=p(a),u=r,c=h["".concat(s,".").concat(u)]||h[u]||m[u]||i;return a?n.createElement(c,o(o({ref:e},d),{},{components:a})):n.createElement(c,o({ref:e},d))}));function u(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l.mdxType="string"==typeof t?t:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},2210:function(t,e,a){a.r(e),a.d(e,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return m}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],l={sidebar_position:4},s="MMR Database",p={unversionedId:"learn/mmrdatabase",id:"learn/mmrdatabase",title:"MMR Database",description:"Overview",source:"@site/docs/learn/mmrdatabase.md",sourceDirName:"learn",slug:"/learn/mmrdatabase",permalink:"/docs/learn/mmrdatabase",editUrl:"https://github.com/minima-global/minidocs/docs/learn/mmrdatabase.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Transactions",permalink:"/docs/learn/transactions"},next:{title:"TxPoW Units (Blocks)",permalink:"/docs/learn/txpowunits"}},d={},m=[{value:"Overview",id:"overview",level:2},{value:"MMR Data",id:"mmr-data",level:2},{value:"Proofs",id:"proofs",level:2},{value:"MMR Sets",id:"mmr-sets",level:2},{value:"Traversing the MMR",id:"traversing-the-mmr",level:2}],h={toc:m};function u(t){var e=t.components,l=(0,r.Z)(t,o);return(0,i.kt)("wrapper",(0,n.Z)({},h,l,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"mmr-database"},"MMR Database"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"As the blockchain is heavily pruned, users must store proof that their coins are unspent. This is the role of the Merkle Mountain Range (MMR) Proof database. The MMR is a ",(0,i.kt)("strong",{parentName:"p"},"hash sum tree")," containing the proofs for all Transaction Outputs (TxOs) i.e. coins in the system.\nNote: these coins may be Spent Transaction Outputs (STxOs) or Unspent Transaction Outputs (UTxOs). "),(0,i.kt)("p",null,"The tree is ",(0,i.kt)("strong",{parentName:"p"},"append-only")," and is updated as coins are spent and created. For each new UTxO created from a transaction output, a new leaf node is created in the MMR. Coins are hashed in pairs, building up the largest ",(0,i.kt)("strong",{parentName:"p"},"binary tree")," possible until a new tree is required. "),(0,i.kt)("p",null,"When the total number of leaf nodes (Coins/TxOs) are not equal to ",(0,i.kt)("em",{parentName:"p"},"2n where n= int{0,...,256}"),", there will be multiple trees of different heights, creating multiple peak nodes as shown below."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Diagram: Merkle Mountain Range (MMR) with 11 coins (green) and three peaks (blue)")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(9713).Z+"#gh-light-mode-only",width:"469",height:"216"}),(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(4834).Z+"#gh-dark-mode-only",width:"469",height:"216"})),(0,i.kt)("p",null,"To create a single MMR tree, the peaks must be collected (or \u2018bagged\u2019) starting from left to right. Until a single root hash is found."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Diagram: A complete Merkle Mountain Range (MMR) with three peaks and root")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(4746).Z+"#gh-light-mode-only",width:"469",height:"315"}),(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(8891).Z+"#gh-dark-mode-only",width:"469",height:"315"})),(0,i.kt)("p",null,"Each node in the tree will have a globally unique reference to it by combining the row/level it is in and its entry number on the row. Using a hash table to track entries, each node can be identified through a reference ","[R,E]"," where R is the row number and E is the Entry number. "),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Diagram: A complete MMR with hash table references ","[row, entry number]")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(457).Z+"#gh-light-mode-only",width:"512",height:"315"}),(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(6578).Z+"#gh-dark-mode-only",width:"512",height:"315"})),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"For example, the second coin with entry number 1 will have a reference in the hash table of ","[0,1]"," (Row 0, Entry 1).")),(0,i.kt)("p",null,"The maximum possible number of rows in the MMR is set to 256, using the MAXROWS parameter. With each two new coins, a new parent node is added, therefore the maximum number of coins in the MMR would result in a perfect binary tree with one peak and 2",(0,i.kt)("sup",null,"256")," coins."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"2",(0,i.kt)("sup",null,"256")," is the maximum number of coins (UTxOs) that can ever exist in Minima.")," "),(0,i.kt)("p",null,"Using the default parameters of 256 transactions per block, 50 second block times and assuming 3 UTxOs per transaction, it would take"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"5,737,098,536,063,750,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000 years to fill the MMR.")),(0,i.kt)("h2",{id:"mmr-data"},"MMR Data"),(0,i.kt)("p",null,"Each node in the MMR has unique MMR Data consisting of a hash and a value, defined as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"MMRData Object"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Leaf Nodes - TxOs (Row 0)"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parent Nodes (inc Peaks & Root)"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Data (Hash)")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Hash(coin object)",(0,i.kt)("br",null),"The coin could be spent or unspent."),(0,i.kt)("td",{parentName:"tr",align:"left"},"Hash","[",(0,i.kt)("br",null),"Hash(left child data object),",(0,i.kt)("br",null),"Hash(right child data object),value object]"),(0,i.kt)("td",{parentName:"tr",align:"left"},"MiniData (32 byte hash)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Minima Value of coin, if",(0,i.kt)("br",null)," unspent,",(0,i.kt)("br",null),"Or 0, if spent"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Sum of the value of child nodes"),(0,i.kt)("td",{parentName:"tr",align:"left"},"MiniNumber")))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Diagram: Example MMR Data for two coins and a parent node in the MMR.")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(3628).Z+"#gh-light-mode-only",width:"301",height:"261"}),(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(6640).Z+"#gh-dark-mode-only",width:"301",height:"261"})),(0,i.kt)("p",null,"Users do not store the complete MMR for all the coins in the system, as this would be too burdensome, rather they only store the entries relevant to their own coins which must be provided as CoinProofs in the Transaction Witness when they wish to spend their coins."),(0,i.kt)("p",null,"Each entry in the MMR is defined by its attributes:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"MMREntry Attribute"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Row")),(0,i.kt)("td",{parentName:"tr",align:null},"The hash table row representing its level in the tree (where coins are Level 0)"),(0,i.kt)("td",{parentName:"tr",align:null},"String")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Entry Number")),(0,i.kt)("td",{parentName:"tr",align:null},"The index of the Entry on a specific row from left to right, starting from 0"),(0,i.kt)("td",{parentName:"tr",align:null},"MMREntryNumber")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Data")),(0,i.kt)("td",{parentName:"tr",align:null},"The MMR data (Hash and Value) of the entry"),(0,i.kt)("td",{parentName:"tr",align:null},"MMRData")))),(0,i.kt)("h2",{id:"proofs"},"Proofs"),(0,i.kt)("p",null,"When a user wishes to spend their coins, they must provide proof that their coins are unspent by providing a ",(0,i.kt)("strong",{parentName:"p"},"CoinProof")," for each coin they wish to spend. ",(0,i.kt)("strong",{parentName:"p"},"A CoinProof is a list of Proof Chunks")," that any other user can use to independently verify that someone else\u2019s coin exists and is unspent, without having to store the proofs for every coin in the network."),(0,i.kt)("p",null,"Given a CoinProof, any node verifying a transaction can calculate the path (i.e. the intermediate parent hashes), from another user's coin to a peak in the MMR. If the calculated peak hash matches the peak hash from their own MMR, the CoinProof is valid, otherwise the CoinProof and transaction are not valid."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Proof Chunks")," consist of the MMR Data (hash and value) for a node and a True/False flag indicating whether the node is a left sibling or not. "),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Diagram: Example CoinProof for coin 7 (coin to peak)")),(0,i.kt)("p",null,(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(5212).Z+"#gh-light-mode-only",width:"512",height:"356"}),(0,i.kt)("img",{loading:"lazy",alt:"MMR Database",src:a(8797).Z+"#gh-dark-mode-only",width:"512",height:"356"})),(0,i.kt)("p",null,"The CoinProof for coin 7 consists of the ProofChunks of yellow entries  ",(0,i.kt)("strong",{parentName:"p"},"{","[0,6]",",","[0,7]",",","[1,2]",", ","[2,0]","}")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Coin entry ","[0,6]"," proves that coin ","[0,7]"," is in parent ","[1,3]"),(0,i.kt)("li",{parentName:"ul"},"Parent ","[1,2]"," proves that parent ","[1,3]"," is in parent ","[2,1]"),(0,i.kt)("li",{parentName:"ul"},"Parent ","[2,0]"," proves that parent ","[2,1]"," is in peak ","[3,0]")),(0,i.kt)("p",null,"Any node receiving this CoinProof (yellow nodes), is able to calculate the parents and the peak node, proving that Coin 7 is valid."),(0,i.kt)("h2",{id:"mmr-sets"},"MMR Sets"),(0,i.kt)("p",null,"When a coin is ",(0,i.kt)("strong",{parentName:"p"},"spent"),", the Spent flag of the coin changes from false to true, changing the hash of the coin."),(0,i.kt)("p",null,"When a new coin is ",(0,i.kt)("strong",{parentName:"p"},"created")," (as an output to a transaction), a new coin is added as a leaf node to the tree."),(0,i.kt)("p",null,"In both cases, the intermediate parent nodes, peaks and root will need to be calculated for the new hash of the coin. Therefore the CoinProofs for all coins in the system change with each new block and it is therefore essential for users to keep up to date with the latest block. "),(0,i.kt)("p",null,"Each block contains an ",(0,i.kt)("strong",{parentName:"p"},"MMR Set")," containing updated and new MMR Entries for all the spent and new coins of the main transaction in the block. "),(0,i.kt)("p",null,"Each block has its own set of MMR entries with the following attributes: "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"MMR Attribute"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Block Time")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The blocktime for the MMR set"),(0,i.kt)("td",{parentName:"tr",align:"left"},"MiniNumber")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Elen")),(0,i.kt)("td",{parentName:"tr",align:"left"},"How many entries in this MMR set"),(0,i.kt)("td",{parentName:"tr",align:"left"},"MiniNumber")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Entry Number")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The latest entry number"),(0,i.kt)("td",{parentName:"tr",align:"left"},"MMREntryNumber")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("strong",{parentName:"td"},"Set Entries")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The ",(0,i.kt)("strong",{parentName:"td"},"hash table")," elements for all the MMR Entries in this set.",(0,i.kt)("br",null),"HashTable<0,1> is the entry on Row 0, Entry index 1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Enumeration of MMR Entries")))),(0,i.kt)("h2",{id:"traversing-the-mmr"},"Traversing the MMR"),(0,i.kt)("p",null,"Starting from any node in the MMR, we can navigate through it as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Operation"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Row Operation"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Entry Number Operation"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Right Sibling"),(0,i.kt)("td",{parentName:"tr",align:"left"},"-"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Add 1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Left Sibling"),(0,i.kt)("td",{parentName:"tr",align:"left"},"-"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Minus 1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Parent"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Add 1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Divide by 2, Round down to nearest integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Left Child"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Minus 1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Multiply by 2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Right Child"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Minus 1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Multiply by 2, Add 1")))),(0,i.kt)("p",null,"Separate MMRs are also used to store Signature Proofs and Script Proofs."))}u.isMDXComponent=!0},4834:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase1Dm-3305d0a9868e227dd4509ed7f9d28bf5.svg"},9713:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase1Lm-fdf5c30ead0060298eefbe3c6b7af5e4.svg"},8891:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase2Dm-7ec0ead31dbdf73f957d6626d0f7114f.svg"},4746:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase2Lm-59e6a8bf94dc8ebb7f9d0d08455ad656.svg"},6578:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase3Dm-9ff559c13dcce1c2cf61af416236f4b3.svg"},457:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase3Lm-de86f2711cf3506f71a3a04687929ec7.svg"},6640:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase4Dm-d759c4a65f704db149599a541b4b41f1.svg"},3628:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase4Lm-dbd2d92f1fd61bf12a60526124a07065.svg"},8797:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase5Dm-2d79b2fe557514d95c2fb35690e53067.svg"},5212:function(t,e,a){e.Z=a.p+"assets/images/mMRDatabase5Lm-d0395ed03260715fbf1fbb1a1ae7e3c5.svg"}}]);