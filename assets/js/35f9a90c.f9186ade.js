"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[2796],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return h}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,u=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=i,d=p["".concat(u,".").concat(h)]||p[h]||m[h]||a;return n?r.createElement(d,o(o({ref:t},l),{},{components:n})):r.createElement(d,o({ref:t},l))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1376:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return m}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],s={sidebar_position:12},u="Quantum Secure",c={unversionedId:"minimawhitepaper/quantumsecure",id:"minimawhitepaper/quantumsecure",title:"Quantum Secure",description:"Quantum security is not an issue right now. But it will be in the future. If you want to remove the need for protocol developers because the protocol is advanced enough to take care of itself, and should not require any Hard Forks ever (there are no Soft Forks on Minima as all users are also miners), you need to use Quantum Secure algorithms.",source:"@site/docs/minimawhitepaper/quantumsecure.md",sourceDirName:"minimawhitepaper",slug:"/minimawhitepaper/quantumsecure",permalink:"/minidocs/docs/minimawhitepaper/quantumsecure",editUrl:"https://github.com/minima-global/minidocs/docs/minimawhitepaper/quantumsecure.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Smart Contracts, Tokens and Transactions",permalink:"/minidocs/docs/minimawhitepaper/smartcontractstokensandtransactions"},next:{title:"Block Size",permalink:"/minidocs/docs/minimawhitepaper/blocksize"}},l={},m=[],p={toc:m};function h(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"quantum-secure"},"Quantum Secure"),(0,a.kt)("p",null,"Quantum security is not an issue right now. But it will be in the future. If you want to remove the need for protocol developers because the protocol is advanced enough to take care of itself, and should not require any Hard Forks ever (there are no Soft Forks on Minima as all users are also miners), you need to use Quantum Secure algorithms."),(0,a.kt)("p",null,"Minima uses the KECCAK hash algorithm for Tx-PoW mining, block and transaction hashes, proof chains, and signing or verifying data. All of the cryptographic security of Minima is provided by hash functions. The scripting language supports SHA2-256 to allow cross-chain hash lock contracts with legacy chains. The signing algorithm is the Winternitz One Time Signature scheme (WOTS). You can build hash trees of valid public keys, and process them in MiniScript, so that you can sign multiple times with the same root public key \u2013 the Merkle Signature Scheme",(0,a.kt)("a",{parentName:"p",href:"/docs/minimawhitepaper/specialthanksto"},"[13]"),"."),(0,a.kt)("p",null,"Quantum security comes at a price. The signatures are at least 10-20x as big as ECDSA, used in Bitcoin. A one time use WOTS is 400-800 bytes. Minima signatures are certainly large when compared to normal Bitcoin transactions, but they are not kept forever since almost all data is eventually pruned, so although a bandwidth issue, they are only a temporary storage overhead."))}h.isMDXComponent=!0}}]);