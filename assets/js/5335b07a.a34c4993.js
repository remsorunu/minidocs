"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[1548],{3905:function(t,n,e){e.d(n,{Zo:function(){return E},kt:function(){return N}});var r=e(7294);function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function l(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function i(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?l(Object(e),!0).forEach((function(n){a(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):l(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function o(t,n){if(null==t)return{};var e,r,a=function(t,n){if(null==t)return{};var e,r,a={},l=Object.keys(t);for(r=0;r<l.length;r++)e=l[r],n.indexOf(e)>=0||(a[e]=t[e]);return a}(t,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(r=0;r<l.length;r++)e=l[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(a[e]=t[e])}return a}var s=r.createContext({}),u=function(t){var n=r.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):i(i({},n),t)),e},E=function(t){var n=u(t.components);return r.createElement(s.Provider,{value:n},t.children)},c={inlineCode:"code",wrapper:function(t){var n=t.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(t,n){var e=t.components,a=t.mdxType,l=t.originalType,s=t.parentName,E=o(t,["components","mdxType","originalType","parentName"]),p=u(e),N=a,T=p["".concat(s,".").concat(N)]||p[N]||c[N]||l;return e?r.createElement(T,i(i({ref:n},E),{},{components:e})):r.createElement(T,i({ref:n},E))}));function N(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var l=e.length,i=new Array(l);i[0]=p;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=t,o.mdxType="string"==typeof t?t:a,i[1]=o;for(var u=2;u<l;u++)i[u]=e[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,e)}p.displayName="MDXCreateElement"},3630:function(t,n,e){e.r(n),e.d(n,{assets:function(){return E},contentTitle:function(){return s},default:function(){return N},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return c}});var r=e(7462),a=e(3366),l=(e(7294),e(3905)),i=["components"],o={sidebar_position:8},s="Smart Contracts",u={unversionedId:"learn/smartcontracts",id:"learn/smartcontracts",title:"Smart Contracts",description:"Minima has its own,Turing Complete, scripting language for creating Smart Contracts.",source:"@site/docs/learn/smartcontracts.md",sourceDirName:"learn",slug:"/learn/smartcontracts",permalink:"/docs/learn/smartcontracts",editUrl:"https://github.com/minima-global/minidocs/docs/learn/smartcontracts.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Coloured Coins",permalink:"/docs/learn/tokenscolouredcoins"},next:{title:"Incentive Program",permalink:"/docs/minimaincentiveprogram"}},E={},c=[{value:"Token Scripts",id:"token-scripts",level:2},{value:"Grammar",id:"grammar",level:2},{value:"Globals",id:"globals",level:2},{value:"Functions",id:"functions",level:2},{value:"Examples",id:"examples",level:2}],p={toc:c};function N(t){var n=t.components,e=(0,a.Z)(t,i);return(0,l.kt)("wrapper",(0,r.Z)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"smart-contracts"},"Smart Contracts"),(0,l.kt)("p",null,"Minima has its own,Turing Complete, scripting language for creating Smart Contracts. "),(0,l.kt)("p",null,"Minima, like Bitcoin, uses the UTxO model so writing smart contracts on Minima is quite different to writing them on an Account based model like Ethereum. "),(0,l.kt)("p",null,"A Minima script (contract) returns TRUE or FALSE. The default is return FALSE, so all scripts must explicitly RETURN TRUE for the transaction to be valid."),(0,l.kt)("p",null,"A script can run for 512 instructions. An instruction is 1 operation or function."),(0,l.kt)("p",null,"The process to create a basic Smart Contract is as follows:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Write a script that will return TRUE when the funds should be spendable"),(0,l.kt)("li",{parentName:"ol"},"Create the script, determining the ",(0,l.kt)("strong",{parentName:"li"},"address")," of the script. The address is the hash of the script. "),(0,l.kt)("li",{parentName:"ol"},"Send funds to the script address and set the state variables, this will lock the funds in a coin."),(0,l.kt)("li",{parentName:"ol"},"Add the coin as an input to a transaction. A transaction in Minima is a set of input coins, a set of output coins and a state variable list from 0-255. Each \u2018coin\u2019 has an ",(0,l.kt)("em",{parentName:"li"},"amount, address (script hash), tokenid and coinid"),". "),(0,l.kt)("li",{parentName:"ol"},"The transaction will only be valid when the script in the input coin returns TRUE, at which point the amount in the coin can be spent - in full.")),(0,l.kt)("p",null,"A \u2018contract\u2019 is the script that locks the funds in a coin and is interchangeable with the word script."),(0,l.kt)("p",null,"A transaction can be signed by 1 or more public keys - and Signatures can even be added as state variables if you want oracle style contracts. Minima script is case sensitive."),(0,l.kt)("p",null,"The addition of the state variables in the MMR Proof DB, allow for complex scripts with knowledge of their past to be created. A simple state mechanic for transactional history rather than a global state for ALL transactions."),(0,l.kt)("p",null,"Each user tracks the coins to an address they possess and all coins that have a public key or address they possess in the STATE or PREVSTATE."),(0,l.kt)("p",null,"Minima transactions are scriptable Logic Gates, with analogue inputs and outputs, a simple yet powerful control language, and a previous history state mechanic."),(0,l.kt)("p",null,"Contracts are inherently compatible with Layer 2. "),(0,l.kt)("p",null,"The scripting language supports SHA2-256 to allow cross-chain hash lock contracts with legacy chains."),(0,l.kt)("p",null,"Types of Contracts possible:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Basic Signed "),(0,l.kt)("li",{parentName:"ul"},"Time Lock "),(0,l.kt)("li",{parentName:"ul"},"Multi-sig "),(0,l.kt)("li",{parentName:"ul"},"Complex multi-sig "),(0,l.kt)("li",{parentName:"ul"},"M of N multi-sig "),(0,l.kt)("li",{parentName:"ul"},"Hashed Time Lock (including cross-chain)"),(0,l.kt)("li",{parentName:"ul"},"Exchange"),(0,l.kt)("li",{parentName:"ul"},"FlashCash"),(0,l.kt)("li",{parentName:"ul"},"MAST ")),(0,l.kt)("p",null,"Example multi-sig contract: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'scripts action:newscript track:true script:"RETURN SIGNEDBY(0x1539C2B974C1589C6AB3C734AA41D8E7D999759EFE057B047B200E836BA526 8A) AND SIGNEDBY(0xAD25E1E40605A68AFE357ECF83E51FE27EC10013851AE95889A00C695D5B94 02)" \n')),(0,l.kt)("h2",{id:"token-scripts"},"Token Scripts"),(0,l.kt)("p",null,"Each token has a separate script that must also return TRUE when attempting to spend a UTxO. For instance this could be 'make sure 1% is sent to this address, for a charity coin, "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"RETURN VERIFYOUT(@INPUT CHARITY_ADDRESS @AMOUNT*0.01 @TOKENID) \n")),(0,l.kt)("p",null,"or a counter mechanism that checks a counter has been incremented:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"RETURN STATE(99) EQ INC(PREVSTATE(99))\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Both the address script and the Token script must return TRUE.")),(0,l.kt)("p",null,"A token by default has RETURN TRUE as it's script. This token structure is added to any transaction wishing to use that token so every user can know how many, what scripts, name etc of the Token is correct and valid."),(0,l.kt)("h2",{id:"grammar"},"Grammar"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"ADDRESS     ::= ADDRESS ( BLOCK )\nBLOCK       ::= STATEMENT_1 STATEMENT_2 ... STATEMENT_n\nSTATEMENT   ::= LET VARIABLE = EXPRESSION |\n                LET ( EXPRESSION_1 EXPRESSION_2 ... EXPRESSION_n ) = EXPRESSION |\n                IF EXPRESSION THEN BLOCK [ELSEIF EXPRESSION THEN BLOCK]* [ELSE BLOCK] ENDIF |\n                WHILE EXPRESSION DO BLOCK ENDWHILE |\n                EXEC EXPRESSION |\n                MAST EXPRESSION |\n                ASSERT EXPRESSION |\n                RETURN EXPRESSION\nEXPRESSION  ::= RELATION\nRELATION    ::= LOGIC AND LOGIC  | LOGIC OR LOGIC  |\n                LOGIC XOR LOGIC  | LOGIC NAND LOGIC |\n                LOGIC NOR LOGIC  | LOGIC NXOR LOGIC | LOGIC\nLOGIC       ::= OPERATION EQ OPERATION  | OPERATION NEQ OPERATION  |\n                OPERATION GT OPERATION  | OPERATION GTE OPERATION  |\n                OPERATION LT OPERATION  | OPERATION LTE OPERATION  | OPERATION\nOPERATION   ::= ADDSUB & ADDSUB | ADDSUB | ADDSUB | ADDSUB ^ ADDSUB | ADDSUB\nADDSUB      ::= MULDIV + MULDIV | MULDIV - MULDIV | MULDIV % MULDIV |\n                MULDIV << MULDIV | MULDIV >> MULDIV | MULDIV\nMULDIV      ::= PRIME * PRIME | PRIME / PRIME | PRIME\nPRIME       ::= NOT PRIME |  NEG PRIME | NOT BASEUNIT | NEG BASEUNIT | BASEUNIT\nBASEUNIT    ::= VARIABLE | VALUE | -NUMBER | GLOBAL | FUNCTION | ( EXPRESSION )\nVARIABLE    ::= [a-z]+\nVALUE       ::= NUMBER | HEX | STRING | BOOLEAN\nNUMBER      ::= ^[0-9]+(\\\\\\\\.[0-9]+)?\nHEX         ::= 0x[0-9a-fA-F]+\nSTRING      ::= [UTF8_String]\nBOOLEAN     ::= TRUE | FALSE\nFALSE       ::= 0\nTRUE        ::= NOT FALSE\nGLOBAL      ::= @BLOCK | @INBLOCK | @BLOCKDIFF | @INPUT |\n                @AMOUNT | @ADDRESS | @TOKENID | @COINID |\n                @SCRIPT | @TOTIN | @TOTOUT\nFUNCTION    ::= FUNC ( EXPRESSION_1 EXPRESSION_2 .. EXPRESSION_n )\nFUNC        ::= CONCAT | LEN | REV | SUBSET | GET | OVERWRITE |\n                CLEAN | UTF8 | REPLACE | SUBSTR |\n                BOOL | HEX | NUMBER | STRING | ADDRESS |\n                ABS | CEIL | FLOOR | MIN | MAX | INC | DEC | SIGDIG | POW |\n                BITSET | BITGET | BITCOUNT | PROOF | KECCAK | SHA2 | SHA3 |\n                SIGNEDBY | MULTISIG | CHECKSIG |\n")),(0,l.kt)("h2",{id:"globals"},"Globals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"@BLOCK       : Block number this transaction is in\n@INBLOCK     : Block number when this output was created\n@BLOCKDIFF   : Difference between @BLOCK and INBLOCK\n@INPUT       : Input number in the transaction\n@COINID      : CoinID of this input\n@AMOUNT      : Amount of this input\n@ADDRESS     : Address of this input\n@TOKENID     : TokenID of this input\n@SCRIPT      : Script for this input\n@TOTIN       : Total number of inputs for this transaction\n@TOTOUT      : Total number of outputs for this transaction\n")),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("p",null,"CONACT ( HEX_1 HEX_2 ... HEX_n )",(0,l.kt)("br",null),"\nConcatenate the HEX values."),(0,l.kt)("p",null,"LEN ( HEX|SCRIPT )",(0,l.kt)("br",null),"\nLength of the data"),(0,l.kt)("p",null,"REV ( HEX )",(0,l.kt)("br",null),"\nReverse the data"),(0,l.kt)("p",null,"SUBSET ( HEX NUMBER NUMBER )",(0,l.kt)("br",null),"\nReturn the HEX subset of the data - start - length"),(0,l.kt)("p",null,"OVERWRITE ( HEX NUMBER HEX NUMBER NUMBER)",(0,l.kt)("br",null),"\nCopy bytes from the first HEX and pos to the second HEX and pos, length the last NUMBER"),(0,l.kt)("p",null,"GET ( NUMBER NUMBER .. NUMBER )",(0,l.kt)("br",null),"\nReturn the array value set with LET ( EXPRESSION EXPRESSION .. EXPRESSION )"),(0,l.kt)("p",null,"ADDRESS ( STRING )",(0,l.kt)("br",null),"\nReturn the address of the script"),(0,l.kt)("p",null,"REPLACE ( STRING STRING STRING )",(0,l.kt)("br",null),"\nReplace in 1st string all occurrence of 2nd string with 3rd"),(0,l.kt)("p",null,"SUBSTR ( STRING NUMBER NUMBER )",(0,l.kt)("br",null),"\nGet the substring"),(0,l.kt)("p",null,"CLEAN ( STRING )",(0,l.kt)("br",null),"\nReturn a CLEAN version of the script"),(0,l.kt)("p",null,"UTF8 ( HEX )",(0,l.kt)("br",null),"\nConvert the HEX value of a script value to a string"),(0,l.kt)("p",null,"BOOL ( VALUE )",(0,l.kt)("br",null),"\nConvert to TRUE or FALSE value"),(0,l.kt)("p",null,"HEX ( SCRIPT )",(0,l.kt)("br",null),"\nConvert SCRIPT to HEX"),(0,l.kt)("p",null,"NUMBER ( HEX )",(0,l.kt)("br",null),"\nConvert HEX to NUMBER"),(0,l.kt)("p",null,"STRING ( HEX )",(0,l.kt)("br",null),"\nConvert a HEX value to SCRIPT"),(0,l.kt)("p",null,"ABS ( NUMBER )",(0,l.kt)("br",null),"\nReturn the absolute value of a number"),(0,l.kt)("p",null,"CEIL ( NUMBER )",(0,l.kt)("br",null),"\nReturn the number rounded up"),(0,l.kt)("p",null,"FLOOR ( NUMBER )",(0,l.kt)("br",null),"\nReturn the number rounded down"),(0,l.kt)("p",null,"MIN ( NUMBER NUMBER )",(0,l.kt)("br",null),"\nReturn the minimum value of the 2 numbers"),(0,l.kt)("p",null,"MAX ( NUMBER NUMBER )",(0,l.kt)("br",null),"\nReturn the maximum value of the 2 numbers"),(0,l.kt)("p",null,"INC ( NUMBER )",(0,l.kt)("br",null),"\nIncrement a number"),(0,l.kt)("p",null,"DEC ( NUMBER )",(0,l.kt)("br",null),"\nDecrement a number"),(0,l.kt)("p",null,"POW ( NUMBER NUMBER )",(0,l.kt)("br",null),"\nReturns the power of N of a number. N must be a whole number."),(0,l.kt)("p",null,"SIGDIG ( NUMBER NUMBER )",(0,l.kt)("br",null),"\nSet the significant digits of the number"),(0,l.kt)("p",null,"BITSET ( HEX NUMBER BOOLEAN )",(0,l.kt)("br",null),"\nSet the value of the BIT at that Position to 0 or 1"),(0,l.kt)("p",null,"BITGET ( HEX NUMBER )",(0,l.kt)("br",null),"\nGet the BOOLEAN value of the bit at the position."),(0,l.kt)("p",null,"BITCOUNT ( HEX )",(0,l.kt)("br",null),"\nCount the number of bits set in a HEX value"),(0,l.kt)("p",null,"PROOF ( HEX HEX HEX )",(0,l.kt)("br",null),"\nCheck the data, mmr proof, and root match. Same as mmrproof on Minima."),(0,l.kt)("p",null,"KECCAK ( HEX|STRING )",(0,l.kt)("br",null),"\nReturns the KECCAK value of the HEX value."),(0,l.kt)("p",null,"SHA2 ( HEX|STRING )",(0,l.kt)("br",null),"\nReturns the SHA2 value of the HEX value."),(0,l.kt)("p",null,"SHA3 ( HEX|STRING )",(0,l.kt)("br",null),"\nReturns the SHA3 value of the HEX value."),(0,l.kt)("p",null,"SIGNEDBY ( HEX )",(0,l.kt)("br",null),"\nReturns true if the transaction is signed by this public key"),(0,l.kt)("p",null,"MULTISIG ( NUMBER HEX1 HEX2 .. HEXn )",(0,l.kt)("br",null),"\nReturns true if the transaction is signed by N of the public keys"),(0,l.kt)("p",null,"CHECKSIG ( HEX HEX HEX)",(0,l.kt)("br",null),"\nCheck public key, data and signature"),(0,l.kt)("p",null,"GETOUTADDR ( NUMBER )",(0,l.kt)("br",null),"\nReturn the HEX address of the specified output"),(0,l.kt)("p",null,"GETOUTAMT ( NUMBER )",(0,l.kt)("br",null),"\nReturn the amount of the specified output"),(0,l.kt)("p",null,"GETOUTTOK ( NUMBER )",(0,l.kt)("br",null),"\nReturn the token id of the specified output"),(0,l.kt)("p",null,"VERIFYOUT ( NUMBER HEX NUMBER HEX )",(0,l.kt)("br",null),"\nVerify the specified output has the specified address, amount and tokenid"),(0,l.kt)("p",null,"GETINADDR ( NUMBER )",(0,l.kt)("br",null),"\nReturn the HEX address of the specified input"),(0,l.kt)("p",null,"GETINAMT ( NUMBER )",(0,l.kt)("br",null),"\nReturn the amount of the specified input"),(0,l.kt)("p",null,"GETINTOK ( NUMBER )",(0,l.kt)("br",null),"\nReturn the token id of the specified input"),(0,l.kt)("p",null,"VERIFYIN ( NUMBER HEX NUMBER HEX)",(0,l.kt)("br",null),"\nVerify the specified input has the specified address, amount and tokenid"),(0,l.kt)("p",null,"STATE ( NUMBER )",(0,l.kt)("br",null),"\nReturn the state value for the given number"),(0,l.kt)("p",null,"PREVSTATE ( NUMBER )",(0,l.kt)("br",null),"\nReturn the state value stored in the MMR data in the initial transaction this input was created. Allows for a state to be maintained from 1 spend to the next"),(0,l.kt)("p",null,"SAMESTATE ( NUMBER NUMBER )",(0,l.kt)("br",null),"\nReturn TRUE if the previous state and current state are the same for the start and end positions"),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'LET thing = 23\nLET ( 12 2 ) = 45.345\nLET ( 0 0 1 ) = 0xFF\nLET ( 3 ( thing + 1 ) ) = [ RETURN TRUE ]\n\n--\n\nRETURN SIGNEDBY ( 0x12345.. )\n\n--\n\nIF SIGNEDBY ( 0x123456.. ) AND SIGNEDBY ( 0x987654.. ) THEN\n   RETURN TRUE\nELSE IF @BLKNUM GT 198765 AND SIGNEDBY ( 0x12345.. ) THEN\n   RETURN TRUE\nENDIF\n\n--\n\nLET x = STATE ( 23 )\nLET shax = KECCAK ( x )\nIF shax EQ 0x6785456.. AND SIGNEDBY ( 0x12345.. ) THEN\n  RETURN TRUE\nENDIF\n\n--\n\nEXEC [ RETURN TRUE ]\n\n--\n\nMAST 0xA6657D2133E29B0A343871CAE44224BBA6BB87A972A5247A38A45D3D2065F7E4\n\n--\n\nASSERT STATE ( 0 ) EQ INC ( PREVSTATE ( 0 ) )\n\n"\n}\n')))}N.isMDXComponent=!0}}]);